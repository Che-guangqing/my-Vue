{"version":3,"file":"vue.js","sources":["../../src/util/index.js","../../src/observe/array.js","../../src/observe/index.js","../../src/state.js","../../src/init.js","../../src/index.js"],"sourcesContent":["// 当前数据是否是对象\nexport function isObject(data) {\n    return typeof data === 'object' && data !== null\n}\n\n// 定义一个不可枚举但是可读的属性\nexport function def(data,key,value) {\n    Object.defineProperty(data, key, {\n        enumerable:false,   //不可枚举\n        configurable:false, //不能被修改\n        value\n    })\n}","// 需要重写能够改变原数组的方法 push shift unshift pop reverse sort splice\n// 先把数组原来的方法保存\nlet oldArraryMethods = Array.prototype\n// value.__proto__ = arraryMethods\n// arraryMethods.__proto__ = oldArraryMethods\nexport const arraryMethods = Object.create(oldArraryMethods)\nconst methods = [\n    'push', \n    'shift',\n    'unshift' ,\n    'pop' ,\n    'reverse' ,\n    'sort' ,\n    'splice'\n]\nmethods.forEach(methods => {\n    arraryMethods[methods] = function (...args) {\n        console.log('调用了方法')\n        // 我调用重写的数组方法 这个方法调用原生的数组方法   AOP切片编程\n        const result = oldArraryMethods[methods].apply(this, ...args)\n        // push unshif添加的元素可能还是对象 \n        let inserted; //当前用户插入的元素\n        let ob = this.__ob__\n        console.log(ob, 'arrrr')\n        switch (methods) {\n            case 'push':\n            case 'unshift':\n                inserted = args\n                break;\n            case 'splice': //操作的数组 操作的索引 新增的属性 arr.splice(0,1,'b')\n                inserted = args.slice(2)\n                break;\n        }\n        // 添加了值\n        if(inserted) {\n            // ob.observeArray(inserted) //将新增属性继续观测\n        }\n        return result\n    }\n})","import {isObject, def} from '../util/index'\nimport {arraryMethods} from './array'\n\n// 观测数据\nclass Observe {\n    constructor(value) {\n        this.walk(value)\n        // console.log(value)\n        // vue如果数据层次过多 则递归解析对象中的属性 ，依次添加set get方法\n        // value.__ob__ = this  //给每一个监控过的对象都添加一个__ob__ 属性  但是这样写会一直递归调用observeArray方法\n        // def(value,'__ob__ ', this)\n        // if(Array.isArray(value)) {\n        //     // 如果属性是数组,则不使用数组的索引添加get set进行观察 性能不好 \n        //     // 如果是unishit push等方法让数组发生变化 则重写这些方法\n        //     value.__proto__ = arraryMethods\n            \n        //     // 如果数组里面是对象我再进行监测\n        //     this.observeArray(value)\n        // }else {\n        //     //对对象进行观测\n        //     this.walk(value)\n        // }\n    }\n    //数组\n    observeArray(value) {\n        for(let i = 0 ;i < value.length; i++) {\n            // [{}] 监控了数组里面的对象\n            observe(value[i])\n        }\n    }\n    //对象\n    walk(data) {\n        let keys = Object.keys(data) // [name,age,address]\n        keys.forEach(key => {\n            defineReactive(data, key, data[key])\n        })\n        // for(let i = 0 ;i <keys.length; i++) {\n        //     // 遍历拿到对象中的属性和值 \n        //     let key = keys[i]\n        //     let value =  data[key]\n        //     // 给每个属性定义响应式数据\n        //     defineReactive(data, key, value)\n        // }\n    }\n}\n\n// 定义响应式数据\nfunction defineReactive(data, key, value) {\n    //                (给谁，定义某个key，值是多少)\n    // 递归实现深度监测 如果对象里面还是对象，不递归只能监测一层数据的变化 用observe方法再判断再循环属性添加set get方法\n    observe(value)\n\n    Object.defineProperty(data, key , {\n        //取值\n        get() {\n            return value\n        },\n        //设置值\n        set(newValue) {\n            console.log('更新数据')\n            if (value === newValue) return;\n            // 值发生变化\n\n            // 如果原来的属性是a:{b:1,c:2} 用户这样赋值 a:{a:2}还是监测不到\n            // 继续劫持用户设置的值 因为有可能用户设置的值是对象 对象劫持\n            observe(newValue)\n\n            // console.log('值发生变化')\n            value = newValue\n        }\n    })\n}\n\n\n\n// 响应式原理 观测数据是否变化\n// 把data中的数据都使用 Object.definedProperty()重新定义\nexport function observe(data) {\n    // console.log(data, 'observe')\n    let isObj = isObject(data) //是否对象\n    // console.log(isObj)\n    //不是对象\n    if(!isObj) { return }\n    // 是对象\n    return new Observe(data) //用来观测数据\n}","import {observe} from './observe/index'\nexport function initState(vm) {\n    const opts = vm.$options\n    // vue的数据来源 属性 方法 数据 计算属性 watch\n    if(opts.props) {\n        initProps(vm)\n    }\n    if(opts.methods) {\n        initMethods(vm)\n    }\n    if(opts.data) {\n        initData(vm)\n    }\n    if(opts.computed) {\n        initComputed(vm)\n    }\n    if(opts.watch) {\n        initWatch(vm)\n    }\n}\nfunction initProps() {}\nfunction initMethods() {}\nfunction initData(vm) {\n    // console.log(vm.$options.data)\n    // 数据初始化\n\n    //用户传递的data 可能是对象或函数\n    let data = vm.$options.data;\n    // 如果拿到的值是函数 就执行它 并且this指向vue实例 并且为了让用户拿到data去修改等操作 把data放在vue实例上\n    data = vm._data = typeof data === 'function' ? data.call(vm):data\n    // console.log(data) //对象data\n\n    // 对象劫持  用户改变了数据 我可以收到通知进行刷新页面（数据可以驱动视图变化）\n    // Object. ()  给属性添加get、set方法\n    observe(data) //响应式原理\n}\nfunction initComputed() {}\nfunction initWatch() {}\n","import {initState} from './state'\n\n// 在Vue构造函数的原型上添加初始化init方法\nexport function initMixin(Vue) {\n    // 初始化流程\n    Vue.prototype._init = function(options) {\n        // console.log(this) //Vue实例\n        // 数据劫持\n        const vm = this; // vue实例\n        // this.$options = 用户传入的配置参数\n        vm.$options = options;\n\n        // 初始化状态\n        initState(vm);\n\n        // 若传入了el属性 需要将页面渲染出来 实现挂在流程\n        // if(vm.$options.el) {\n        //     vm.$mount(vm.$options.el)\n        // }\n    }\n    // Vue.prototype.$mount = function (el) {\n    //     const vm = this;\n    //     const options = vm.$options\n    //     el = document.querySelector(el)\n    //     // 默认优先级 render, template, el\n    //     if(!options.render) {\n    //         // 对模板进行编译\n    //         let template = options.template\n    //         if(!template && el) {\n    //             template = el.outerHTML\n    //         }\n    //         console.log(template, 'ttt')\n    //     }\n    // }\n}\n","import {initMixin} from './init'\n\nfunction Vue(options) {\n    // vue初始化操作\n    this._init(options)\n}\n\n// 通过引入文件的方式给Vue原型上添加方法\n// 导入init方法 \ninitMixin(Vue)\n\nexport default Vue"],"names":["isObject","data","oldArraryMethods","Array","prototype","arraryMethods","Object","create","methods","forEach","console","log","args","result","apply","inserted","ob","__ob__","slice","Observe","value","walk","i","length","observe","keys","key","defineReactive","defineProperty","get","set","newValue","isObj","initState","vm","opts","$options","props","initData","computed","watch","_data","call","initMixin","Vue","_init","options"],"mappings":"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"}